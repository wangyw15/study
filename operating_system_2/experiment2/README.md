# 实验（二）死锁观察与避免

# 一、目的与要求

## 1、目的

死锁会引起计算机工作僵死，造成整个系统瘫痪。因此，死锁现象是操作系统特别是大型系统中必须设法防止的。学生应独立的使用高级语言编写和调试一个系统动态分配资源的简单模拟程序，观察死锁产生的条件，并采用适当的算法，有效的防止死锁的发生。通过实习，更直观地了解死锁的起因，初步掌握防止死锁的简单方法，加深理解课堂上讲授过的知识。

## 2、要求

1. 设计一个n个并发进程共享m个系统资源的系统。进程可动态地申请资源和释放资源。系统按各进程的申请动态地分配资源。
2. 系统应能显示各进程申请和释放资源以及系统动态分配资源的过程，便于用户观察和分析。
3. 系统应能选择是否采用防止死锁算法或选用何种防止算法（如有多种算法）。在不采用防止算法时观察死锁现象的发生过程。在使用防止死锁算法时，了解在同样申请条件下，防止死锁的过程。

# 二、示例

## 1、题目

本示例采用银行算法防止死锁的发生。假设有三个并发进程共享十个系统。在三个进程申请的系统资源之和不超过10时，当然不可能发生死锁，因为各个进程申请的资源都能满足。在有一个进程申请的系统资源数超过10时，必然会发生死锁。应该排除这二种情况。程序采用人工输入各进程的申请资源序列。如果随机给各进程分配资源，就可能发生死锁，这也就是不采用防止死锁算法的情况。假如，按照一定的规则，为各进程分配资源，就可以防止死锁的发生。示例中采用了银行算法。这是一种犹如“瞎子爬山”的方法，即探索一步，前进一步，行不通，再往其他方向试探，直至爬上山顶。这种方法是比较保守的。所花的代价也不小。

## 2、算法与框图

银行算法，顾名思义是来源于银行的借贷业务，一定数量的本金要应付各种客户的借贷周转，为了防止银行因资金无法周转而倒闭，对每一笔贷款，必须考察其最后是否能归还。研究死锁现象时就碰到类似的问题，有限资源为多个进程共享，分配不好就会发生每个进程都无法继续下去的死锁僵局。银行算法的原理是先假定每一次分配成立，然后检查由于这次分配是否会引起死锁，即剩下的资源是不是能满足任一进程完成的需要。如这次分配是安全的（不会引起死锁），就实施这次分配，再假定下一次分配。如果不安全，就不实施，再作另一种分配试探，一直探索到各进程均满足各自的资源要求，防止了死锁的发生。

# 三、实习题

1. 编制和调试示例给出的死锁观察与避免程序，使其投入运行，并用进程的各种资源请求序列测试死锁的形成和避免死锁的过程。
2. 修改并调试一个使用有序资源使用法来预防死锁的模拟程序，并用进程的各种资源请求序列测试死锁的形成和预防死锁的过程。

提示：首先要把系统中所有资源类别按其紧缺程度排成一定的序号。要求进程必须严格按递增次序请求资源，即对低序号设备的要求未能满足之前，不准申请高序号的资源，这样就能有效地预防死锁的产生。

# 四、思考题

编制一个利用可在使用资源图的资源请求矩阵和分配矩阵的简化运算来检测死锁的模拟程序。

提示：可再使用资源图的分配矩阵为$(A^{ij})$，元素$A^{ij}=|(R^j,P^i)|$；请求矩阵为$(B^{ij})$，元素$A^{ij}=|(P^i,R^j)|$，还需要一个

$$
r_j=t_j-\sum\limits_k|(R_j,P_k)|
$$

可用资源向量$(r^j)$，元素。其中，P表示进程，R表示资源，t表示某类资源的总数。

简化过程是：先设法满足请求边，使它变成分配边，然后把只有分配边而无请求边的节点的所有分配边撤销（相当于解放已全部满足某进程的所有资源）。再次检查能否将请求边变成分配边，再撤销已无请求边的所有分配边，直至撤销所有的边，此时，可再使用资源图完全可化简。如果状态是死锁，当且仅当它的可再使用资源图不是完全可化简的。也就是肯定有一些边无法撤消。本实习要求用矩阵的运算来实现这过程。
