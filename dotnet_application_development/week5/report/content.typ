#let week = 5
#let experiments = (
  (
    name: [类、对象、方法、类的继承的综合练习],
    purpose: [
      + 编制程序实现账户系统，并要求设计一个 `test` 程序和模拟数据，演示上述各项功能。
      + 要求先设计一个抽象类，活期账户类和储蓄存款账户类继承并实现这个抽象类。
      ],
    requirement: [
      假设您是一家银行的开发人员。请定义一个账户系统。这些账户是：
      - 活期账户（checking account）
      - 储蓄存款账户（savings account）
      
      ==== （1）活期账户
      活期账户具有以下特征：
      - 账户拥有者的名字只能在创建账户时指定
      - 初始存额（opening balance）必须在账户创建时指定
      - 账户创建时必须分配账户号，活期账户的账号范围从 100000－499999，
      
      每个活期账户必须具有唯一的账户号。
      
      活期账户持有者能够：
      - 订购支票薄
      - 检查账户余额
      - 往账户中加钱
      - 如果活期账户中资金充足，可以从中取钱，但不能透支。
      
      ==== （2）储蓄存款账户
      储蓄存款账户具有如下特征：
      - 账户持有者的名字只能在创建账户时指定
      - 储蓄存款账户的账户号的范围从 500000－999999
      - 账户可以赚取利息，利息取决于账户的余额，余额大于 1000，年利息为6％，否则为 3％
      
      储蓄存款账户持有者能够：
      - 检查账户余额
      - 往账户中加钱
      - 如果账户中资金充足，可以从中取钱，但不能透支。
    ],
    result: [
      #figure(image("bank_result.png", width: 100%), caption: [银行账户系统的运行结果])

      #figure(image("bank_uml.png", width: 100%), caption: [银行账户系统的UML图])

      无法实例化抽象类，避免出现没有意义的账户。
    ]
  ),
  (
    name: [接口的实现],
    purpose: [接口的实现],
    requirement: [
      本实验通过两个接口来定义 MP3 或者 MP4 播放器的功能，熟悉接口的设计，显式接口成员的实现，但是因为课程内容和实验规模的限制，方法中只能用文字来象征性地表明它们的功能。
    ],
    result: [
      #figure(image("player_result.png", width: 100%), caption: [MP3的运行结果])

      实现接口需要在类中实现接口的所有成员，否则会出现编译错误。

      显式接口成员实现是一个类成员，只通过指定接口进行调用。通过在类成员前面加上接口名称和句点可命名该类成员。显式接口成员实现中不能包含访问修饰符、`abstract`、`virtual`、`override` 或 `static` 修饰符。显式接口成员属于接口的成员，而不是类的成员，因此，不能使用类对象直接访问，只能通过接口对象来访问。
    ]
  ),
  (
    name: [结构的优越性和局限性],
    purpose: [结构的优越性和局限性],
    requirement: [
      - 分析类定义并改为结构。
      - 设计一个包含 15 个 `Point` 类的对象的数组；设计一个包含 15 个 `Point` 结构的对象的数组。
      - 完成整个程序，输出上述两个数组。
    ],
    result: [
      在 C\# 中，结构体是值类型数据结构，用来封装多个不同类型的变量。它使得一个单一变量可以存储各种数据类型的相关数据。`struct` 关键字用于创建结构体。

      C\# 中的结构与传统的 C 或 C++ 中的结构不同。C\# 中的结构有以下特点：
      - 结构可带有方法、字段、索引、属性、运算符方法和事件。
      - 结构可定义构造函数，但不能定义析构函数。但是，您不能为结构定义无参构造函数。无参构造函数是自动定义的，且不能被改变。
      - 与类不同，结构不能继承其他的结构或类。
      - 结构不能作为其他结构或类的基础结构。
      - 结构可实现一个或多个接口。
      - 结构成员不能指定为 `abstract`、`virtual` 或 `protected`。
      - 当使用 `new` 操作符创建一个结构对象时，会调用适当的构造函数来创建结构。与类不同，结构可以不使用 `new` 操作符即可被实例化。如果不使用 `new` 操作符，只有在所有的字段都被初始化之后，字段才被赋值，对象才被使用。

      结构体在某些情况下可以提供更好的性能，因为它们是值类型，所以在分配和释放内存时比引用类型更快。此外，结构体可以在栈上分配内存，而不是在堆上，这也有助于提高性能。但是，结构体的局限性也很明显，它们不能继承其他结构或类，也不能作为其他结构或类的基础结构，这使得结构体的使用受到了很大的限制。

      在 C\# 中，结构体是值类型，而类是引用类型。将结构体对象数组作为方法参数时，数组中的每个元素都会被复制一份传递给方法。这可能会导致性能下降，特别是当结构体较大时。相反，当您将类对象数组作为方法参数时，只有数组的引用被传递给方法，而不是数组中的每个元素。

      因此，在选择使用结构体对象数组还是类对象数组作为方法参数时，需要根据具体情况进行权衡。如果需要在方法中修改数组中的元素并且希望这些更改在方法外部可见，那么使用类对象数组可能更合适。但是，如果不需要在方法中修改数组中的元素或者不希望这些更改在方法外部可见，那么使用结构体对象数组可能更合适。
    ]
  ),
  (
    name: [程序分析及改错],
    purpose: [程序分析及改错],
    requirement: [程序分析及改错],
    result: [
      - （1）是错误的，因为子类`B`在构造函数中没有调用父类的构造函数，因此出现错误。改正方法则是在`B`的构造函数中调用父类的构造函数：`public B(int j) : base(j)`。
      - （2）是错误的。`A`中的`s`是受保护的，因此不能在主函数中访问，将其改为`public`；`B`中调用父类的构造函数的参数错误，仅需要一个，改为`public B(int j, string t, char d) : base(d)`。
    ]
  ),
)
