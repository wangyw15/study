# 第2周实验

## 实验1 单步调试技术

以下为执行`foreach`语句时每一步执行的内容

```csharp
int s in arrInt
Console.WriteLine(s)
```

## 实验2 使用断点调试技术

### 第1部分

步骤4的输出为`北京上海`

步骤5的输出为`0123456789`

在步骤5中，因为`TextBox.Text`属性的类型为`string`类型，`+`代表拼接两个字符串，不会自动把字符串转换为整数类型

如果要得到两数之和，需要将代码改为如下所示

```csharp
textBox3.Text = (int.Parse(textBox1.Text) + int.Parse(textBox2.Text)).ToString();
```

### 第2部分

单击“联接”按钮后命中断点，程序暂停运行，所以`textBox3.Text`的值没有改变

- 自动窗口
  - 显示当前断点周围使用的变量
- 局部变量窗口
  - 显示在当前局部范围内定义的变量，通常是当前函数或方法内
- 监视窗口
  - 显示自己添加的要监视的变量或表达式

### 第3部分

执行步骤2前`textBox3.Text`的值为空，执行后变为`北京广州`

步骤5

- `textBox1.Text`
  - 北京
- `textBox2.Text`
  - 广州
- `textBox3.Text`
  - 京广线：北京到广州

步骤

- `textBox1.Text`
  - 保持`北京`不变
- `textBox2.Text`
  - 保持`广州`不变
- `textBox3.Text`
  - 从空字符串变为`北京广州`

## 实验3 使用“堆栈调用”窗口

1. `00007FF825B0AF9B  mov         edx,dword ptr [rbp+70h]  `
2. 局部变量里显示了当前函数被调用时的形参和内部变量；调用堆栈则是函数的调用链
  - 递归程序执行过程的特点是：1、递归就是方法里调用自身；2、在使用递增归策略时，必须有一个明确的递归结束条件，称为递归出口；3、解题通常显得很简洁，但运行效率较低；4、在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。

# 实验4 简单程序的编制

略

# 实验5 关于相等性问题

## 预期

```
a == b: True
Object.Equals(a, b): True

a == f: True
Object.Equals(a, f): False

t1 == t2: False
Object.Equals(t1, t2): False
```

## 实际

```
a == b: True
Object.Equals(a, b): True

a == f: True
Object.Equals(a, f): False

t1 == t2: False
Object.Equals(t1, t2): False
```

## 原因

对于`a`和`b`来说，数值都是`1`且类型相同，这些常数都是被存储在一个固定的区域，赋值时指向这一块区域，不必新开辟一块内存来存储，因此`a`与`b`指向同一块内存空间，都是相等的。

对于`a`和`f`来说，数值都是`1`，在`int`和`float`比较是会进行自动类型转换，`a`与`f`在数值上相等，因此相等；而这两个变量的类型不同，尽管都会作为常值存储在固定区域，但是类型不同存储在不同区域，因此对象不相同。

对于`t1`和`t2`来说，是分别新建的两个实例，因此完全不相等。

# 实验6 将交错数组转换成一维数组

## 实验内容

将交错数组中两个数组中的字符串无重复地组合并赋值到一个新的一维数组中。

## 技术要点

这是一段C#代码，它的作用是将用户输入的7个单词分成两组作为交错数组，然后将第一组中的每个单词与第二组中的每个单词组合在一起，用&符号连接。最后，将所有组合输出到控制台。

这段代码涉及到了C#中的数组、列表、循环等基本语法，也涉及到了遍历交错数组的内容。

同时对于输入也用到了`string.Split`方法，将字符串以给定字符为界分割为数组。
