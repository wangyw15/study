# 实验三 进程管理及进程通信

# 一. 实验目的

利用 Linux 提供的系统调用设计程序，加深对进程概念的理解。 

体会系统进程调度的方法和效果。

了解进程之间的通信方式以及各种通信方式的使用。

# 二. 实验准备

复习操作系统课程中有关进程、进程控制的概念以及进程通信等内容（包括软中断通信、管道、消息队列、共享内存通信及信号量概念）。

熟悉本《实验指导》第五部分有关进程控制、进程通信的系统调用。它会引导你学会怎样掌握进程控制。

阅读例程中的程序段。

# 三. 实验方法

用 `vi` 编写 c 程序（假定程序文件名为 `program0.c`）

编译程序
```bash
$ gcc -o program0 program0.c
```
或
```bash
$ cc -o program0 program0.c
```
运行
```bash
$./program0
```

# 四. 实验内容及步骤

> 用 `vi` 编写使用系统调用的 C 语言程序。

1. 编写程序。显示进程的有关标识（进程标识、组标识、用户标识等）。经过 5 秒钟 后，执行另一个程序，最后按用户指示（如：Y/N）结束操作。
   - 程序使用的系统调用原型请参见本《实验指导》第五部“Linux 编程系统调用”中“有关进程的系统调用”部分的相关内容。
   - 可参考 [program0.c](src/program0.c)
2. 参考[program1.c](src/program1.c)，编写程序。实现父进程创建一个子进程。体会子进程与父进程分别获得不同返回值，进而执行不同的程序段的方法。
   - 思考：子进程是如何产生的？ 又是如何结束的？子进程被创建后它的运行环境是怎样建立的？
3. 参考 [program2.c](src/program2.c)，编写程序。父进程通过循环语句创建若干子进程。探讨进程的家族树以及子进程继承父进程的资源的关系。
   - 思考
      - ① 画出进程的家族树。子进程的运行环境是怎样建立的？反复运行此程序看会有什么情况？解释一下。
      - ② 修改程序，使运行结果呈单分支结构，即每个父进程只产生一个子进程。画出进程树，解释该程序。可参考 [program2_mod](src/program2_mod.c)
4. 参考 [program3.c](src/program3.c) 编程，使用 `fork()` 和 `exec()` 等系统调用创建三个子进程。子进程分别启动不同程序，并结束。反复执行该程序，观察运行结果，结束的先后，看是否有不同次序。
   - 思考：子进程运行其它程序后，进程运行环境怎样变化的？反复运行此程序看会有什么情况？解释一下。
5. 参考 [program4.c](src/program4.c) 编程，验证子进程继承父进程的程序、数据等资源。如用父、子进程修改公共变量和私有变量的处理结果；父、子进程的程序区和数据区的位置。
   - 思考：子进程被创建后，对父进程的运行环境有影响吗？解释一下。
6. 参照《实验指导》第五部分中“管道操作的系统调用”。复习管道通信概念，参考 [program5.c](src/program5.c)，编写一个程序。父进程创建两个子进程，父子进程之间利用管道进行通信。要求能显示父进程、子进程各自的信息，体现通信效果。
   - 思考
      - ① 什么是管道？进程如何利用它进行通信的？解释一下实现方法。
      - ② 修改睡眠时机、睡眠长度，看看会有什么变化。请解释。
      - ③ 加锁、解锁起什么作用？不用它行吗？
7. 编程验证：实现父子进程通过管道进行通信。进一步编程，验证子进程结束，由父进程执行撤消进程的操作。测试父进程先于子进程结束时，系统如何处理“孤儿进程”的。
   - 思考：对此作何感想，自己动手试一试？解释一下你的实现方法。
   - 参考 [program5.c](src/program5.c) 的注释并修改测试
8. 编写两个程序一个是服务者程序，一个是客户程序。执行两个进程之间通过消息机制通信。消息标识MSGKEY 可用常量定义，以便双方都可以利用。客户将自己的进程标识（pid）通过消息机制发送给服务者进程。服务者进程收到消息后，将自己的进程号和父进程号发送给客户，然后返回。客户收到后显示服务者的 pid 和 ppid，结束。以下 [program6_server.c](src/program6_server.c) 和 [program6_client.c](src/program6_client.c) 基本实现以上功能。这部分内容涉及《实验指导》第五部分中“IPC系统调用”。先熟悉一下，再调试程序。
   - 实验可以在后台运行服务器进程（命令行后加& ），前台运行客户进程或用不同终端运行客户进程。并可通过ps 命令察看后台进程。用Shell编写一个脚本程序。先在后台启动服务程序，再在前台反复执行多个客户程序，观察系统反映。体会客户/服务器体系结构。实验结束向服务器发出终止服务的信号。
   - 思考：想一下服务者程序和客户程序的通信还有什么方法可以实现？解释一下你的设想，有兴趣试一试吗。
9. 这部分内容涉及《实验指导》第五部分中“有关信号处理的系统调用”。编程实现软中断信号通信。父进程设定软中断信号处理程序，向子进程发软中断信号。子进程收到信号后执行相应处理程序。
   - 思考：这就是软中断信号处理，有点儿明白了吧？讨论一下它与硬中断有什么区别？看来还挺管用，好好利用它。
   - 参考 [program7.c](src/program7.c)
10. 怎么样，试一下吗？用信号量机制编写一个解决生产者—消费者问题的程序，这可是受益匪浅的事。本《实验指导》第五部分有关进程通信的系统调用中介绍了信号量机制的使用。

# 五. 研究并讨论
1. 讨论 Linux 系统进程运行的机制和特点，系统通过什么来管理进程？
2. C 语言中是如何使用 Linux 提供的功能的？用程序及运行结果举例说明。
3. 什么是进程？如何产生的？举例说明。
4. 进程控制如何实现的？举例说明。
5. 进程通信方式各有什么特点？用程序及运行结果举例说明。
6. 管道通信如何实现？该通信方式可以用在何处？
7. 什么是软中断？软中断信号通信如何实现？
