// 实验几
#let number = "九"
// 姓名
#let student_name = "someone"
// 学号
#let student_id = "some id"
// 上课时间
#let time = "sometime"
// 机位
#let seat = "somewhere"
// 指导教师
#let teacher = "someone"

// 实验名称
#let name = "程序转移机制"
// 实验目的
#let purpose = ("学习实现程序转移的硬件机制。", "掌握堆栈寄存器的使用。")
// 实验原理
#let principle = [
    == 1. 程序转移
    在任何一个程序段的内部，执行流程有顺序、分支、循环三种，而程序段之间又有相互调用（例如：调用子程序、中断服务、子程序返回、进程调度、任务切换……），看似很复杂，其实计算机硬件用非常简单的技术解决了这些问题。
    
    分支和循环总是可以相互替代，所以也常说程序段内的执行流程其实仅有顺序和转移两种，而程序段之间的调用也只是把执行流程转移到了另外一个程序段上。所以，任何复杂的程序流程，在硬件实现机制上只有两种情况：顺序执行和转移。硬件实现这两种情况的技术很简单：
    
    - 对PC寄存器的自动加1功能实现程序顺序执行。
    - 对PC寄存器的打入初值功能实现程序转移。
    
    当转移目标为本段内未执行过的指令时就形成分支；当转移目标是本段内执行过的指令时就形成循环；当转移目标为其他段的指令时就形成段间调用。可见：转移操作决定于“给PC赋值”，而转移类型决定于“所赋的值同当前指令的关系”。 
    
    == 2. 实验箱系统的程序转移硬件机制
    当LDPC有效（即：LDPC=0）时，如果此时DBUS上的值就是转移的目标地址，则此目标地址被打入PC（即：PC被赋新值），从而实现程序的转移。
    若LDPC为0是附带条件的，就形成“条件转移”。实验箱依靠“PC打入电路”实现“有进位”时转移和“计算结果为零”时转移，以及无条件转移。

    == 3. 子程序调用和保护断点
    子程序的调用和返回是两次转移，特殊点在于：返回时转移的目标一定是调用时转移的出发点。为实现这个特点，在调用转移时必须把出发地址（即：断点地址）保存起来。这个“保存”还必须有以下两个要求：
    
    + 不被一般用户所知或改变。
    + 返回转移时能方便地找到它。
    
    第一个要求决定了它不能被保存在数据存储区或程序存储区，第二个要求决定了返回指令的目标地址获得方法与其它转移指令完全不同，返回指令的目标地址一定从一个特殊的“保存区”得到，指令本身不需要再带目标地址，而其他转移指令必须自带目标地址。再考虑到子程序调用的“可嵌套性”，这个“保护区”里的数据应该有“先入后出”特点，这与“货栈”中堆放的货物相似，故称其为“堆栈”。堆栈的容量决定了子程序的嵌套深度。
    
    各系统实现堆栈的技术各不相同。实验箱系统用一个锁存器（574芯片）构成堆栈寄存器（ST）。由于574芯片只能存放一个字节，所以，本系统的子程序调用深度只有1级，不能形成子程序嵌套。

    == 4. ST寄存器结构和子程序调用与返回控制信号
    实验箱子程序调用和返回的结构由PC电路和ST电路组成。

    + 当调用子程序时，PC的当前值（即：断点地址)经下面的245送上DBUS，进入ST保存。然后给PC打入子程序入口地址，该子程序入口地址是由调用指令自身携带的目标地址，至此转子程序过程完成。
    + 当子程序返回（RET）时，返回指令开启ST的输出，并给出PC打入信号（无条件转移），于是ST保存的断点经由DBUS打入PC，实现子程序返回。

]

// 实验内容
#let tasks = (
    (
        // 实验任务名称
        name: [试用手动方式实现子程序调用转移过程。假设调用子程序指令的下一条指令存放在11H单元，子程序的入口地址为22H。],
        // 实验步骤
        steps: [
            - 通过分析实验任务要求，需要首先将当前`PC`寄存器的值（即断点地址） 11H保存在`ST`寄存器中。接着，将子程序的入口地址22H送入`PC`寄存器。
            - 本试验任务需要以下控制信号
            #table(
                columns: (auto, auto, auto),
                inset: 10pt,
                align: horizon,
                [*序号*], [*控制信号名称*], [*作用*],
                [1], [X#sub[2]X_#sub[1]X_#sub[0]], [选择输出寄存器],
                [2], [STEN], [将输入打入`ST`寄存器],
                [3], [ELP], [将数据打入`PC`寄存器],
                [4], [AEN], [将数据打入`A`寄存器],
            )

            + 用手动方式来实现任务一，用`TV/ME`键将实验箱调整至手动方式
            + J#sub[1]与J#sub[2]相连
            + 设置`PC`为11H：K#sub[23]-K#sub[16]=11H，X#sub[2]X_#sub[1]X_#sub[0]=000，`ELP`=0，按下STEP键
            + 设置`A`为22H：K#sub[23]-K#sub[16]=22H，X#sub[2]X_#sub[1]X_#sub[0]=000，`AEN`=0，按下STEP键
            + 将`PC`的值打入`ST`：X#sub[2]X_#sub[1]X_#sub[0]=011，`STEN`=0，按下STEP键
            + 将`A`的值打入`PC`：K#sub[23]-K#sub[16]=FFH，X#sub[2]X_#sub[1]X_#sub[0]=100，`ELP`=0，按下STEP键
        ],
        // 实验现象
        phenomena: [
            #figure(image("images/task1.jpg", width: 100%), caption: [实验1最终结果])
        ],
        // 数据记录、分析与处理
        data: [
            - 在第一次按下`STEP`键之后，`PC`的值变为11H
            - 第二次按下之后，`A`的值变为22H
            - 第三次按下之后，`ST`的值变为11H
            - 第四次按下之后，`PC`的值变为22H
        ],
        // 实验结论
        conclusion: [
            通过手动控制信号，控制数据的读取和写入，可以模拟实现子程序调用转移过程。
        ]
    ),
    (
        name: [试用手动方式实现子程序返回转移过程。假设调用子程序指令的下一条指令存放在11H单元，子程序的入口地址为22H。],
        steps: [
            - 接线与实验一相同
            - 实验一完成后，实验箱显示`PC`=22H，`A`=22H，`ST`=11H
            + 将`ST`打入`PC`：X#sub[2]X_#sub[1]X_#sub[0]=010，`ELP`=0，按下STEP键
        ],
        phenomena: [
            #figure(image("images/task2.jpg", width: 100%), caption: [实验2最终结果])
        ],
        data: [
            此时实验箱显示`PC`=11H，`A`=22H，`ST`=11H
        ],
        conclusion: [
            通过手动控制信号，控制数据的读取和写入，可以模拟实现子程序返回转移过程。
        ]
    ),
    (
        name: [编程实现OUT寄存器交替显示11和55，交替频率为可以清晰辨识，且不小于每秒一次。 (实验箱的工作频率为：114.8Hz。)],
        steps: [
            由实验指导书可知，实验箱的`CPI`为4，因此实验箱的指令运行频率为$114.8/4=28.7 op("Hz")$，即每秒28.7条。因此每秒交替一次可以转换为执行`29`条指令。

            可以编写程序：
            ```assembly
            LOOP1: MOV A, #11H
                   OUT
                   CALL DELAY
                   MOV A, #55H
                   OUT
                   CALL DELAY
                   JMP LOOP1
            DELAY: MOV A, #29H
            LOOP:  SUB A, #01H
                   JZ EXIT
                   JMP LOOP
            EXIT:  RET
                   END
            ```
        ],
        phenomena: [
            #figure(image("images/task3_11.jpg", width: 100%), caption: [`OUT`输出11H])
            #figure(image("images/task3_55.png", width: 100%), caption: [`OUT`输出55H])
        ],
        data: [
            `OUT`交替输出11H和55H
        ],
        conclusion: [
            通过执行指令可以实现延时功能
        ]
    ),
)

// 建议和体会
#let experience = [
    通过手动控制信号可以实现子程序调用和范围的功能；通过编写程序循环执行空指令可以实现延时功能。
]

// 思考题
#let thinking = [
    若要求11和55各显示50次后停机，应该如何修改程序？

    使用`W`寄存器存放交替显示的次数，将`W`初始值设置为50D=32H，每次交替显示后将`W`减一，当`W`为0时跳入死循环实现停机功能。
]
