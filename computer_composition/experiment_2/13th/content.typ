// 实验几
#let number = "十三"
// 姓名
#let student_name = "诗和远方"
// 学号
#let student_id = "不便透露"
// 上课时间
#let time = "有空就行"
// 机位
#let seat = "随心所欲"
// 指导教师
#let teacher = "自力更生"

// 实验名称
#let name = "建立指令流水系统"
// 实验目的
#let purpose = ("了解指令流水系统的设计方式。", "编制一条可以流水方式运行的指令。")
// 实验原理
#let principle = [
    + 硬部件的并行工作
      在实验3的“实验过程举例”中我们用一条微指令完成了“A+W”后右移一位的值送OUT的操作，这个操作明显地可以分成三个子操作：A+W、把“和”右移一位、把值送OUT。这三个子操作为什么可以同时进行呢？因为这三个子操作使用的硬件（包括总线）互不相同，于是可以同时工作。这一特点表现在微指令编码上，就是这三个子操作的微指令码中为低电平（有效）的都不相同，于是可以将这三个子操作的微指令码合并成一个微指令，就是实验3 谈到的结果： c23~c0=1111 1111 1101 11 11 1011 1000=ff df b8H 。这个微指令控制三部分硬件并行工作。
    + 指令流水执行
      把 “使用不同硬件的操作可以同时工作”的概念推广到相继的两条指令之间，就形成“指令的流水线执行模式”。
      这个模式下，同一时间有多条指令各自在不同的硬件中执行，而对同一条指令而言，不同时间顺序在不同的硬件中执行，很像在流水型生产线上的产品，  同时刻顺序在不同的工位上加工。这就是指令流水模式的名称来源。
      显然，要形成指令流水模式，每条指令都应该分成几个独立的子操作，当前趋指令的后几个子操作与后继指令的前几个子操作不使用同样的硬件时，系统就可设计成流水线方式。
      现代计算机大都采用指令流水模式，但这个模式会使中断响应过程变得复杂，所以实时系统中多是有限地采用它。
    + 实验箱系统的指令流水硬件基础
      实验箱系统的各种基本操作我们已经熟悉，其中的很多操作可以在不同的硬件中同时执行，典型的是“取指令”的微操作，其微指令码微CBFFFF，与大多数的微操作无关。在厂家给的默认指令系统中这个操作编在了每条指令的最后一个状态，即每条指令的操作完成后就取进下一条指令。这是典型的“取指、执行、取指……”模式。即一条指令先被“取指”，再执行其他微操作，完成后再取下一条指令。
      如果一条指令的最后一个微操作与取指无关，就可以把二者合并成一个微指令，于是这个指令的最后一个微操作与取下一条指令并行进行。对下一条指令而言，其“取指”与“其他操作”在不同硬件中顺序执行——指令二级流水。
    + 实验箱系统实现指令流水的技巧
      由背景知识3可知：一条指令的最后一个微操作与取指无关，就可以把二者合并成一个微指令。这个原则用微操作码表述就是：
      若取指令操作（CBFFFF）与它前面的微操作码没有相同的位为0，则这两个微操作码的“与”就是二者合并后的微指令。在程序中这条指令就会和它的后继指令形成二级流水模式。
      例如：指导书108页的IN指令有两个状态T1和T0，T1状态的微指令码为FFFF17，T0状态的微指令码为CBFFFF，二者为0的位都不相同，故IN指令可以被改造为流水型指令“CBFF17 ”，为T1和T0微指令码的“与”运算值。 
]

// 实验内容
#let tasks = (
    (
        // 实验任务名称
        name: [分析流水指令集 insfile2.MIC],
        // 实验步骤
        steps: [
            相比 insfile1.MIC 中的指令，流水指令集的指令将用到不同计算机部件的指令进行按位与，将多条指令合并为一条，实现流水线执行，减少每一条指令的微指令数量，减少占用时钟周期以提升程序运行速度。
        ],
        // 实验现象
        phenomena: [
            无
        ],
        // 数据记录、分析与处理
        data: [
            无
        ],
        // 实验结论
        conclusion: [
            流水线指令集能提升运行速度。
        ]
    ),
    (
        name: [改造实验十二中自己编制的指令集，使其中至少一条指令成流水方式。],
        steps: [
            根据参考流水线指令集，对mic文件进行修改，使其成为流水线指令集。
            ```

            _FETCH_     T0 00 CBFFFF
                           01 FFFFFF
                           02 FFFFFF
                           03 FFFFFF
            LD A,#*     T1 04 C7FFF7
                        T0 05 CBFFFF
                           06 FFFFFF
                           07 FFFFFF
            A-W A,#*    T1 08 C7FFEF
                        T0 09 CBFE90
                           0A FFFFFF
                           0B FFFFFF
            跳到 *      T1 0C C6FFFF
                        T0 0D CBFFFF
                           0E FFFFFF
                           0F FFFFFF
            OUTA        T0 10 CBDF9F
                           11 FFFFFF
                           12 FFFFFF
                           13 FFFFFF
            延时        T0 14 CBFFFF
                           15 FFFFFF
                           16 FFFFFF
                           17 FFFFFF
            ```
            主要改动在于将取指令操作（CBFFFF）与它前面的微操作码没有相同的位为0的微操作码进行按位与，将多条指令合并为一条，实现流水线执行。
            例如A-W和OUTA，将取指令操作在不冲突的情况下合并，得到CBFE90，即A-W的流水指令。
            对OUTA进行同样的处理可以得到CBDF9F，即OUTA的流水指令。
        ],
        phenomena: [
            在采用流水线指令之后，程序运行速度有所提升。体现在数字交换的频率加快，因为对于多余的空指令直接跳过，减少了每条指令所需要的实现，实现程序加速。
        ],
        data: [
            为了让现象更为明显，对延时指令也进行了流水线处理，将取值指令放到最前，这样可以减少延时指令的执行时间，使得数字交换的频率更快，让现象更为明显。对于其他指令来说，重复执行次数过少，流水线指令集的区别难以辨认，但是实际也减少了两个时钟周期的占用，同样提升了速度。
        ],
        conclusion: [
           流水线指令集能提升运行速度。
        ]
    ),
)

// 建议和体会
#let experience = [
    通过本次实验，我对流水线指令集有了更深刻的理解，对于流水线指令集的编写也有了更多的思路，可以通过流水线指令集提升程序运行速度。
]

// 思考题
#let thinking = [
    计组实验课临近尾声，请你对该课程的授课形式、实验内容等提出你的建议。

    换一套实验箱，或者学习实际的指令集，例如RISC-V。
]
